:- module(prologue, [
	'\\+'/1,
	'is'/1,
	'='/2,
	'\\='/2,
	'>'/2,
	'<'/2,
	'>='/2,
	'<='/2,
	'=='/2,
	'\\=='/2,
	'#<'/2,
	'#>'/2,
	'#<='/2,
	'#>='/2,
	':='/2,
	'?='/2,
	';'/2,

	nl/0,
	todo/2
]).
:- use_module(list).
:- use_module(math).

% This is a single-line comment.
%: This is a documentation comment.
% This is another single-line comment that isn't part of the documentation.
%: TODO: List of work to be done.
todo('Global', X) :- member(X, ['Unicode', 'Modules', 'Coroutining', 'Foreach/Forall', 'Try/Catch', 'Regex']).
todo('C#', X) :- member(X, ['Generators', 'CLR Attributes']).
todo('Interpreter', X) :- member(X, ['Metapredicates', 'User-defined operators', 'Basic typesystem']).
todo('Parser', X) :- member(X, ['Directives']).
todo('AST', X) :- member(X, ['Annotations']).

nl :- @print('\n').

% OPERATOR DECLARATIONS
'\\+'(A) :- @unprovable(A), @cut.
'is'(A, B) :- @eval(A, B).
'='(A, B) :- @unify(A, B).
'\\='(A, B) :- \+(A = B).
'>'(A, B) :- @evalcmp(A > B).
'<'(A, B) :- @evalcmp(A < B).
'>='(A, B) :- @evalcmp(A >= B).
'<='(A, B) :- @evalcmp(A <= B).
'=='(A, B) :- @compare(0, A, B).
'\\=='(A, B) :- @not(@compare(0, A, B)).
'#<'(A, B)  :- @compare(X, A, B), X  < 0.
'#<='(A, B) :- @compare(X, A, B), X <= 0.
'#>'(A, B)  :- @compare(X, A, B), X  > 0.
'#>='(A, B) :- @compare(X, A, B), X >= 0.
':='(A, B) :- @set(A, B).
'?='(A,B) :- \+@unifiable(A,B,[_|_]).
';'(A, _) :- A.
';'(_, B) :- B.